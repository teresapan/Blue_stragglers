@node Macro, Meta, Lweight, Commands

@iftex
@syntax Macro.
@end iftex
@example
Syntax: MACRO EDIT name
        MACRO LIST [begin end ]
        MACRO name [ narg ] @{ body @}
        MACRO name [ narg ] < body >
        MACRO name DELETE
        MACRO name #1 #2
        MACRO READ file
        MACRO WRITE file
        MACRO DELETE file
        MACRO WRITE name [ + ] file
@end example
@pindex Macro
@findex plot macros

MACRO EDIT name allows you to edit a macro. All the commands available to
the history editor area available (including the ^ history), except
that @key{control-M} inserts
a line before the cursor, @key{control-N} and @key{control-P} get the next and
previous lines respectively, and @key{control-V} and ESC-v move forwards and
backwards 5 lines at a time.
To exit use @key{control-X}
(or whatever you have bound to @code{exit_editor}).
The macro need not exist, and both its name and number of arguments can be
changed by editing the zeroth line of the macro (@key{control-P} from the
first line. If this line is corrupted, or deleted, no changes are made to the
macro when you exit. If the number of arguments is negative, the macro will be
deleted when you exit.) You may prefer to use the macro @code{ed} instead of
MACRO EDIT, as it doesn't appear on the history list and, if invoked
without a macro name will edit the macro that you edited last. Incidently,
@code{hm} (`help macro') will list the last macro that you edited with @code{ed}.
The keybindings may be changed with READ EDIT.

LIST MACRO lists all currently defined macros, or all those which are
between @code{begin} and @code{end} alphabetically (asciily). If VERBOSE is
0, macros starting with ## are not listed.

MACRO @code{name [narg] @{ body @}} defines @code{name} to be @code{body},
where @code{name} is a
single word, and @code{body} may be anything (most users need not
worry about the form in angle brackets; it is occasionally useful when
writing clever macros). A macro is invoked by
typing its name. 
The optional @code{nargs} is the number of arguments the macro expects,
default 0.

If the macro's body is defined to be @code{delete}, the macro is deleted.
MACRO @code{name} DELETE also deletes a macro.

Arguments are referred to as $1, $2, @dots{} $n, up to a maximum of $9.
$0 gives the name of the macro. If the number of arguments has
more than one digit (e.g. 03 or 12), the macro is taken to have a variable
number of arguments, between the `tens' digit and the `units' digit.
For example, @code{12} means 1 or 2 arguments, @code{39} means between
3 and 9 arguments, and @code{02} means 0, 1, or 2. Confused?  @code{HELP}
will tell you what SM knows about a macro's arguments.
There's one problem here; if you say
@example
MACRO woosie 01 @{
   if($?1) @{
      echo An argument: $1
   @} else @{
      echo No arguments
   @}
@}
@end example
@noindent
SM will interpret that @code{01} as the integer @code{1} before the macro's
defined, so that's equivalent to @code{MACRO woosie 1 @{ @dots{} @}}.  So you
cleverly say @code{MACRO woosie "01" @{ @dots{} @}}; but that won't work either
as the closing @code{"} is seen before the 01's parsed; you have to say
@code{MACRO woosie "01 " @{ @dots{} @}} --- and that does work.
@footnote{See discussion of double quotes in @pxref{Quoting} if you want to
know why.} You don't
have to go through any such contortions in files read by @code{MACRO READ},
but they have their own problems.
@findex macro, variable number of arguments
@findex weird, variable number of macro arguments

If the number
declared is greater than 99 the last argument will extend to the end
of the line, and may consist of many words. When called, all the arguments 
must appear on the same line as the macro itself. This line may, as
usual, be ended with an explicit \n. The macro can determine whether
it has been supplied a given argument by using the @code{$?} construction
(see DEFINE). It is also possible to change the values of arguments
using DEFINE just as usual, and even to DEFINE arguments that you
didn't declare. These are temporary variables, local to the macro, and
will disappear when you exit the macro.

Macros must end in space or newline, and if they don't SM will silently
add one (why? to prevent the macro stack being popped prematurely
@pxref{Command Internals}). If you want to defeat this, end your
macro with an explicit #, e.g. @code{macro echo @{WRITE STANDARD#@}}; a
slightly less efficient
alternative would be @code{macro echo 111 @{WRITE STANDARD $1@}}.

MACRO @code{name #1 #2} defines macro name to consist of lines #1 --- #2
of the history buffer.
If #1 or #2 is negative it is interpreted
relative to the current command, so saying @code{MACRO last2 -1 -2}
will define a macro @code{last2} consisting of the last 2 commands issued.

MACRO READ @code{file} reads the macros in @code{file} and defines them.
See RESTORE for how to also restore the history buffer from macro @code{all}.

MACRO DELETE @code{file} has the effect of deleting all macros defined in
@code{file}.

MACRO WRITE @code{file} writes all currently defined macros to @code{file} in
alphabetical order.
If the file exists, and @code{$noclobber} is defined, SM will refuse to
overwrite the file.  You can set @code{noclobber} by specifying it in
your @file{.sm} file.

MACRO WRITE @code{name [ + ] file} writes the macro @code{name} to @code{file}.
If the @code{+} is specified, or the file is the
same as for the previous use of this command, the macro is written to the
bottom of the file, otherwise the file is created.
If the file exists and you aren't simply appending, and @code{$noclobber} is
defined, SM will refuse to overwrite the file.
You can set @code{noclobber} by specifying it in your @file{.sm} file.
